#region Proprietary License
/*----------------------------------------------------------------------------
* This file (CK.StObj.Engine\AmbientContract\AmbientContextualTypeInfo.cs) is part of CK-Database. 
* Copyright Â© 2007-2014, Invenietis <http://www.invenietis.com>. All rights reserved. 
*-----------------------------------------------------------------------------*/
#endregion

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Diagnostics;

namespace CK.Core
{

    /// <summary>
    /// Contextual type information: it is an <see cref="AmbientTypeInfo"/> inside a <see cref="Context"/>.
    /// Offers persistent access to attributes that support <see cref="IAttributeAmbientContextBound"/> interface.
    /// </summary>
    public class AmbientContextualTypeInfo<T, TC> : AmbientContextualAttributesCache
        where T : AmbientTypeInfo
        where TC : AmbientContextualTypeInfo<T, TC>
    {
        readonly TC _generalization;
        TC _specialization;

        /// <summary>
        /// Initializes a new <see cref="AmbientContextualTypeInfo{T,TC}"/>. 
        /// Attributes must be retrieved with <see cref="AmbientContextualAttributesCache.GetCustomAttributes">GetCustomAttributes</see> methods.
        /// </summary>
        /// <param name="t">Type.</param>
        /// <param name="generalization">Generalization in this context. Null if this is the root of the specialization path.</param>
        /// <param name="context">Context.</param>
        /// <remarks>
        /// Contextual type information are built top-down (from generalization to most specialized type).
        /// Once the ultimate leaf (AbstractTypeCanBeInstanciated) has been computed and no ambiguities occur, initialization
        /// is done bottom-up through <see cref="InitializeBottomUp"/>.
        /// </remarks>
        internal protected AmbientContextualTypeInfo( T t, TC generalization, IContextualTypeMap context )
            : base( t.Type, generalization == null )
        {
            AmbientTypeInfo = t;
            Context = context;
            _generalization = generalization;
        }

        /// <summary>
        /// Second step of initialization called once a valid Type path has been found.
        /// </summary>
        /// <param name="specialization">The specialization. Null if this is the leaf.</param>
        /// <param name="abstractTypeInfo">Optional info generated by AbstractTypeCanBeInstanciated.</param>
        internal virtual void InitializeBottomUp( TC specialization, object abstractTypeInfo )
        {
            _specialization = specialization;
        }

        /// <summary>
        /// Contextless type information.
        /// </summary>
        public readonly T AmbientTypeInfo;

        /// <summary>
        /// Context of this contextual type information.
        /// </summary>
        public IContextualTypeMap Context { get; private set; }

        /// <summary>
        /// Gets the specialization in this <see cref="Context"/>. 
        /// Null if this is the leaf of the specialization path.
        /// </summary>
        public TC Specialization { get { return _specialization; } }

        /// <summary>
        /// Gets the generalization in this <see cref="Context"/>. 
        /// Null if this is the root of the specialization path.
        /// </summary>
        public TC Generalization { get { return _generalization; } }

        /// <summary>
        /// Gets whether this Type (that is abstract) must actually be considered as an abstract type or not.
        /// An abstract class may be considered as concrete if there is a way to concretize an instance. 
        /// This is called only for abstract types and if <paramref name="assembly"/> is not null.
        /// </summary>
        /// <param name="monitor">The monitor to use.</param>
        /// <param name="assembly">The dynamic assembly to use for generated types if necessary.</param>
        /// <param name="abstractTypeInfo">Optional object that could be associated to concretize an abstract type.</param>
        internal protected virtual bool AbstractTypeCanBeInstanciated( IActivityMonitor monitor, DynamicAssembly assembly, out object abstractTypeInfo )
        {
            Debug.Assert( AmbientTypeInfo.Type.IsAbstract && assembly != null );
            abstractTypeInfo = null;
            return false;
        }

        /// <summary>
        /// Overridden to return the name of the type in the context.
        /// </summary>
        /// <returns>Formatted name.</returns>
        public override string ToString()
        {
            return AmbientContractCollector.FormatContextualFullName( Context.Context, Type );
        }
    }

}
